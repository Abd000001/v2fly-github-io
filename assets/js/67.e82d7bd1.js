(window.webpackJsonp=window.webpackJsonp||[]).push([[67],{454:function(t,e,a){"use strict";a.r(e);var n=a(11),i=Object(n.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"mkcp-protocol"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mkcp-protocol"}},[t._v("#")]),t._v(" mKCP Protocol")]),t._v(" "),a("p",[t._v("mKCP is a streaming transport protocol modified from the "),a("a",{attrs:{href:"https://github.com/skywind3000/kcp",target:"_blank",rel:"noopener noreferrer"}},[t._v("KCP"),a("OutboundLink")],1),t._v(" protocol, it can transfer any data stream in order.")]),t._v(" "),a("h2",{attrs:{id:"version"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#version"}},[t._v("#")]),t._v(" Version")]),t._v(" "),a("p",[t._v("mKCP has no version number, compatibility between versions are not guaranteed.")]),t._v(" "),a("h2",{attrs:{id:"dependencies"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dependencies"}},[t._v("#")]),t._v(" Dependencies")]),t._v(" "),a("h3",{attrs:{id:"base-protocol"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#base-protocol"}},[t._v("#")]),t._v(" Base Protocol")]),t._v(" "),a("p",[t._v("mKCP is based on the UDP protocol, all communications use UDP.")]),t._v(" "),a("h3",{attrs:{id:"functions"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#functions"}},[t._v("#")]),t._v(" Functions")]),t._v(" "),a("ul",[a("li",[t._v("fnv: "),a("a",{attrs:{href:"https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function",target:"_blank",rel:"noopener noreferrer"}},[t._v("FNV-1a"),a("OutboundLink")],1),t._v(" hash function\n"),a("ul",[a("li",[t._v("Input is a string with variable length;")]),t._v(" "),a("li",[t._v("Output is an unsigned 32-bit integer;")])])])]),t._v(" "),a("h2",{attrs:{id:"communcation-procedure"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#communcation-procedure"}},[t._v("#")]),t._v(" Communcation Procedure")]),t._v(" "),a("ol",[a("li",[t._v("mKCP splits data stream into many small packets. Each data stream has a unique identifier for classification. Each packet has the same unique indentifier with its parent data stream.")]),t._v(" "),a("li",[t._v("mKCP has no handshake procedure. When a packet is received, its data stream unique identifier will be used to determine whether it is a new connection or a existing connection.")]),t._v(" "),a("li",[t._v("Each data packet includes many segments. There are three types of segment: data, acknowledge (ACK) and ping. Each segment needs to be processed individually.")])]),t._v(" "),a("h2",{attrs:{id:"data-format"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#data-format"}},[t._v("#")]),t._v(" Data Format")]),t._v(" "),a("h3",{attrs:{id:"data-packet"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#data-packet"}},[t._v("#")]),t._v(" Data Packet")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("4 Bytes")]),t._v(" "),a("th",[t._v("2 Bytes")]),t._v(" "),a("th",[t._v("L Bytes")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("Authentication Info A")]),t._v(" "),a("td",[t._v("Length L")]),t._v(" "),a("td",[t._v("Segments Section S")])])])]),t._v(" "),a("p",[t._v("其中：")]),t._v(" "),a("ul",[a("li",[t._v("A = fnv(S), big endian;")]),t._v(" "),a("li",[t._v("Segment sections may include multiple segments;")])]),t._v(" "),a("h3",{attrs:{id:"data-segment"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#data-segment"}},[t._v("#")]),t._v(" Data Segment")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("2 Bytes")]),t._v(" "),a("th",[t._v("1 Bytes")]),t._v(" "),a("th",[t._v("1 Bytes")]),t._v(" "),a("th",[t._v("4 Bytes")]),t._v(" "),a("th",[t._v("4 Bytes")]),t._v(" "),a("th",[t._v("4 Bytes")]),t._v(" "),a("th",[t._v("2 Bytes")]),t._v(" "),a("th",[t._v("L Bytes")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("Identifier Id")]),t._v(" "),a("td",[t._v("Command Cmd")]),t._v(" "),a("td",[t._v("Options Opt")]),t._v(" "),a("td",[t._v("Timestamp Ts")]),t._v(" "),a("td",[t._v("Serial Number Sn")]),t._v(" "),a("td",[t._v("Unconfirmed Serial Number Usn")]),t._v(" "),a("td",[t._v("Length L")]),t._v(" "),a("td",[t._v("Data")])])])]),t._v(" "),a("p",[t._v("Definition:")]),t._v(" "),a("ul",[a("li",[t._v("Identifier Id: mKCP data stream identifier")]),t._v(" "),a("li",[t._v("Command Cmd: constant 0x01")]),t._v(" "),a("li",[t._v("Options Opt: values:\n"),a("ul",[a("li",[t._v("0x00: empty")]),t._v(" "),a("li",[t._v("0x01: all data transfered")])])]),t._v(" "),a("li",[t._v("Timestamp Ts: time when the packet is sent at remote，big endian")]),t._v(" "),a("li",[t._v("Serial Number Sn: the position of the segment in the data stream, the serial number of the initial segment is 0, increase 1 on each segment afterwards")]),t._v(" "),a("li",[t._v("Unconfirmed Serial Number Una: smallest unconfirmed Serial Number remote host is currently sending")])]),t._v(" "),a("h3",{attrs:{id:"ack-segment"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ack-segment"}},[t._v("#")]),t._v(" ACK Segment")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("2 Bytes")]),t._v(" "),a("th",[t._v("1 Bytes")]),t._v(" "),a("th",[t._v("1 Bytes")]),t._v(" "),a("th",[t._v("4 Bytes")]),t._v(" "),a("th",[t._v("4 Bytes")]),t._v(" "),a("th",[t._v("4 Bytes")]),t._v(" "),a("th",[t._v("2 Bytes")]),t._v(" "),a("th",[t._v("L * 4 Bytes")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("Identifier Id")]),t._v(" "),a("td",[t._v("Command Cmd")]),t._v(" "),a("td",[t._v("Options Opt")]),t._v(" "),a("td",[t._v("Window Wnd")]),t._v(" "),a("td",[t._v("Next Serial Number Sn")]),t._v(" "),a("td",[t._v("Timestamp Ts")]),t._v(" "),a("td",[t._v("Length L")]),t._v(" "),a("td",[t._v("Received Serial Numbers")])])])]),t._v(" "),a("p",[t._v("Definition:")]),t._v(" "),a("ul",[a("li",[t._v("Identifier Conv: mKCP data stream identifier")]),t._v(" "),a("li",[t._v("Command Cmd: constant 0x00")]),t._v(" "),a("li",[t._v("Options Opt: same as above")]),t._v(" "),a("li",[t._v("Window Wnd: largest acceptable serial number of the remote host")]),t._v(" "),a("li",[t._v("Next Serial Number Sn: smallest serial number that remote host hasn't receive.")]),t._v(" "),a("li",[t._v("Timestamp Ts: timestamp of the newest segment remote host received, can be used to calculate latency")]),t._v(" "),a("li",[t._v("Received Serial Numbers: each with length of 4 bytes, implies that the cooresponding data of that Serial Number is received")])]),t._v(" "),a("p",[t._v("P.S.:")]),t._v(" "),a("ul",[a("li",[t._v("Remote host looks forward to receive data within the range [Sn, Wnd)")])]),t._v(" "),a("h3",{attrs:{id:"ping-segment"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ping-segment"}},[t._v("#")]),t._v(" Ping Segment")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("2 Bytes")]),t._v(" "),a("th",[t._v("1 Bytes")]),t._v(" "),a("th",[t._v("1 Bytes")]),t._v(" "),a("th",[t._v("4 Bytes")]),t._v(" "),a("th",[t._v("4 Bytes")]),t._v(" "),a("th",[t._v("4 Bytes")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("Identifier Conv")]),t._v(" "),a("td",[t._v("Command Cmd")]),t._v(" "),a("td",[t._v("Options Opt")]),t._v(" "),a("td",[t._v("Unconfirmed Serial Number Una")]),t._v(" "),a("td",[t._v("Next Serial Number Sn")]),t._v(" "),a("td",[t._v("Latency Rto")])])])]),t._v(" "),a("p",[t._v("Definition:")]),t._v(" "),a("ul",[a("li",[t._v("Identifier Conv: mKCP data stream identifier")]),t._v(" "),a("li",[t._v("Command Cmd: values:\n"),a("ul",[a("li",[t._v("0x02: connection forcibly closed by the remote host")]),t._v(" "),a("li",[t._v("0x03: normal ping")])])]),t._v(" "),a("li",[t._v("Options Opt: same as above")]),t._v(" "),a("li",[t._v("Unconfirmed Serial Number Una: Una of the same segment")]),t._v(" "),a("li",[t._v("Next Serial Number Sn: Sn of the same segment")]),t._v(" "),a("li",[t._v("Latency Rto: latency calculated by the remote host")])])])}),[],!1,null,null,null);e.default=i.exports}}]);